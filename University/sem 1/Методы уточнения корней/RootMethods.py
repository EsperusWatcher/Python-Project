import math as m

# Методы для нахождения корней уравнения с точностью eps на заданном промежутке

def f(x):
	return x ** 3 + x - 2
# ------------------------------------------------------
# Метод дихотомии(бисекции)
# Рассматриваемый интервал должен пересеекать 0
# Вычисляется средняя позиция в интервале и значение ф-ции в ней
# Если значение удовлетворяет условию |f(mid)| < eps, то return
# Иначе вычисляется знак f(mid) и передается в рекурсию так, чтобы в новой последовательности
# Было пересечение с 0
def dihotomy(a,b,eps):
	c = (a + b) / 2
	if abs(f(c)) < eps:
		return c
	if f(c) * f(a) < 0:
		return dihotomy(a,c,eps)
	else:
		return dihotomy(c,b,eps)
# ------------------------------------------------------
# Метод Хорд
# Начальная хорда проходит через точки
# С(a,f(a)) : D(b,f(b))
def chord(a, b, eps):
	xn = (a * f(b) - b * f(a)) / (f(b) - f(a)) # Уравнение хорды через 2 точки в точке пересечения с осью
	if abs(f(xn)) < eps:
		return xn
	if f(a) * f(xn) < 0:
		return chord(a,xn,eps)
	else:
		return chord(xn,a,eps)
# ------------------------------------------------------
# Метод Итераций
# !!! требуется подобрать сходящуюся эквивалентную функцию, выраженную через х
# x = f(x)
# Затем значение постепенно уточняется, приближаясь к нужному корню
def iterations(a,b, eps):
	result = a # В качестве начальных данных берется значение ф-ции в начале интервала
	x = 2 / (a ** 2 + 1)
	while abs(result - x) > eps:
		result = x
		x = 2 / (x ** 2 + 1)
	return x
# ------------------------------------------------------
a = -10 # Начало и конец интервала уточнения
b = 10
eps = 0.001
print("Уравнение: y = x^3 + x - 2")
print("Рассматриваемый интервал: [{},{}]".format(a,b) )
print("Выбранная точность: ", eps)
print()
print("Метод дихотомии: ", dihotomy(a,b,eps))
print("Метод хорд: ", chord(a,b,eps))
print("Метод итераций: ", iterations(a, b, eps))
a = input()